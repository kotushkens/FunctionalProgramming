# Лабораторная работа №1

### Цель:
Освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы вам предлагается решить несколько задач [проекта Эйлер](https://projecteuler.net/archives). Список задач -- ваш вариант.

Для каждой проблемы должно быть представлено несколько решений:

1. монолитные реализации с использованием:
    - хвостовой рекурсии;
    - рекурсии (вариант с хвостовой рекурсией не является примером рекурсии);
2. модульной реализации, где явно разделена генерация последовательности, фильтрация и свёртка (должны использоваться функции reduce/fold, filter и аналогичные);
3. генерация последовательности при помощи отображения (map);
4. работа со спец. синтаксисом для циклов (где применимо);
5. работа с бесконечными списками для языков, поддерживающих ленивые коллекции или итераторы как часть языка (к примеру Haskell, Clojure);
6. реализация на любом удобном для вас традиционном языке программирования для сравнения.

Требуется использовать идиоматичный для технологии стиль программирования.

### Решения:
#### Задача №5:

>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

1. Хвостовая рекурсия

Решение "в лоб" - ищем от единицы до n такое число, которое будет
делиться без остатка на все числа до bound включительно.

Используется bounded-функция helper с сохранением результата
и выхода из функции без повторных вычислений после разложения рекурсии.
```haskell
smallestDividendByAll :: Int -> Int
smallestDividendByAll bound = helper 1 1 bound
  where
    helper n result bound
      | n > bound = result
      | result `mod` n == 0 = helper (n+1) result bound
      | otherwise = helper 1 (result+1) bound
```

2. Рекурсия (с использованием built-in LCM)

При помощи рекурсивного вызова функции LCM из пакета Prelude
ищем наименьшее удовлетворяющее условиям число.

``` haskell
lcmForList :: [Integer] -> Integer
lcmForList [] = 1
lcmForList [x] = x
lcmForList (x:xs) = lcm x (lcmForList xs)
```





