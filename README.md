# Лабораторная работа №0

### Задачи:

Поверхностное ознакомление с предлагаемыми к использованию технологиями по открытым источникам;
выбор языка программирования и подбор инструментальных средств (компилятор/интерпретатор, система сборки, системы автоматического форматирования, lint tools, инструменты тестирования, стиль кодирования);
написание эссе объёмом порядка страницы, в рамках которого необходимо:


+ обосновать свой выбор языка программирования;
высказать соображения на предмет лабораторной работы номер 4;
привести планируемые к использованию инструментальные средства и список прочитанных статей / книг / руководств при подготовки эссе;


+ выбор книги, по которой вы будете знакомиться с технологией, текст которой необходимо показать на защите данной лабораторной работы и по которой выбудете готовиться к зачёту;


+ защита эссе, при этом возможны общие вопросы о невыбранных технологиях.

## Эссе

Для выполнения лабораторных работ мной был выбран функциональный язык Haskell, 
в первую очередь потому, что он [считается наиболее популярным языком для понимания 
концептов функциональных парадигм, множество code sample'ов по теме описывается именно на этом языке.](https://hackernoon.com/what-functional-language-should-i-learn-5e4157ff574f)
Изначально я хотела выбрать F#, но изучив буквально пару книг (например, `Get Programming with F# by Isaac Abraham`)
осознала, что эти книги рассчитаны на более практическое применение языка, не вдаваясь в особенности концепта функционального программирования,
однако данный курс ставит перед собой такую цель, как ознакомление с рекурсями, системами типов, работой с памятью, а именно эти аспекты
можно рассмотреть в Haskell, работая с кучей разнообразной литературы по теме.
Основной источник, который я буду использовать для изучения, это книга `Practical Haskell by Alejandro Serrano Mena`.

Вдовесок хочу отметить, что я ознакомилась с неофициальным плагином для Intellij IDEA `IntelliJ Haskell`,
с ним удобно работать (он самостоятельно генерирует структуру проекта и форматирует код), а библиотека `HUnit`
для тестирования напоминает мне о старой доброй Java, и изучение Haskell не выглядит таким страшным занятием :)

Для подготовки были использованы материалы, доступные выше по гиперссылке, а также следующие статьи:
1. [Вопрос с Quora](https://www.quora.com/What-are-some-reasons-for-choosing-to-learn-Haskell)
2. [Статья на русском языке для поверхностного ознакомления с другими языками](https://www.itweek.ru/business/article/detail.php?ID=209957#:~:text=Clojure%2C%20Elixir%2C%20Elm%2C%20F%23,для%20функционального%20программирования%20(ФП).)



# Лабораторная работа №1

### Цель:
Освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

В рамках лабораторной работы вам предлагается решить несколько задач [проекта Эйлер](https://projecteuler.net/archives). Список задач -- ваш вариант.

Для каждой проблемы должно быть представлено несколько решений:

1. монолитные реализации с использованием:
    - хвостовой рекурсии;
    - рекурсии (вариант с хвостовой рекурсией не является примером рекурсии);
2. модульной реализации, где явно разделена генерация последовательности, фильтрация и свёртка (должны использоваться функции reduce/fold, filter и аналогичные);
3. генерация последовательности при помощи отображения (map);
4. работа со спец. синтаксисом для циклов (где применимо);
5. работа с бесконечными списками для языков, поддерживающих ленивые коллекции или итераторы как часть языка (к примеру Haskell, Clojure);
6. реализация на любом удобном для вас традиционном языке программирования для сравнения.

Требуется использовать идиоматичный для технологии стиль программирования.

### Решения:
#### Задача №5:

>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

1. Хвостовая рекурсия

```haskell
smallestDivisibleByAll bound = helper 1 1 bound
  where
    helper n result bound
      | n > bound = result
      | result `mod` n == 0 = helper (n+1) result bound
      | otherwise = helper 1 (result+1) bound
```






